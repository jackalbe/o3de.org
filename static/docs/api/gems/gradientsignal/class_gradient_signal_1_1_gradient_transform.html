<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine GradientSignal Gem API Reference: GradientSignal::GradientTransform Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="/images/api-reference/api-ref-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine GradientSignal Gem API Reference
   &#160;<span id="projectnumber">2205.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>GradientSignal</b></li><li class="navelem"><a class="el" href="class_gradient_signal_1_1_gradient_transform.html">GradientTransform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_gradient_signal_1_1_gradient_transform-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GradientSignal::GradientTransform Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada6e9c163506cf63ef32fae7ad3813e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gradient_signal_1_1_gradient_transform.html#ada6e9c163506cf63ef32fae7ad3813e5">GradientTransform</a> (const AZ::Aabb &amp;shapeBounds, const AZ::Matrix3x4 &amp;transform, bool use3d, float frequencyZoom, GradientSignal::WrappingType wrappingType)</td></tr>
<tr class="separator:ada6e9c163506cf63ef32fae7ad3813e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7534aaf61f2e8c5a2a094e263101413a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gradient_signal_1_1_gradient_transform.html#a7534aaf61f2e8c5a2a094e263101413a">operator==</a> (const <a class="el" href="class_gradient_signal_1_1_gradient_transform.html">GradientTransform</a> &amp;rhs) const</td></tr>
<tr class="separator:a7534aaf61f2e8c5a2a094e263101413a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c24eb157b31f188ccaf02148ea4999c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gradient_signal_1_1_gradient_transform.html#a9c24eb157b31f188ccaf02148ea4999c">operator!=</a> (const <a class="el" href="class_gradient_signal_1_1_gradient_transform.html">GradientTransform</a> &amp;rhs) const</td></tr>
<tr class="separator:a9c24eb157b31f188ccaf02148ea4999c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5a91cdc1619a4623e3fe416630e894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gradient_signal_1_1_gradient_transform.html#a4f5a91cdc1619a4623e3fe416630e894">TransformPositionToUVW</a> (const AZ::Vector3 &amp;inPosition, AZ::Vector3 &amp;outUVW, bool &amp;wasPointRejected) const</td></tr>
<tr class="separator:a4f5a91cdc1619a4623e3fe416630e894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e02576fc20963d69f03a02a88f66f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gradient_signal_1_1_gradient_transform.html#a94e02576fc20963d69f03a02a88f66f7">TransformPositionToUVWNormalized</a> (const AZ::Vector3 &amp;inPosition, AZ::Vector3 &amp;outUVW, bool &amp;wasPointRejected) const</td></tr>
<tr class="separator:a94e02576fc20963d69f03a02a88f66f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a805dfc248488ca5bb26a981a69d34265"><td class="memItemLeft" align="right" valign="top">static constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gradient_signal_1_1_gradient_transform.html#a805dfc248488ca5bb26a981a69d34265">UvEpsilon</a> = 0.001f</td></tr>
<tr class="separator:a805dfc248488ca5bb26a981a69d34265"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ada6e9c163506cf63ef32fae7ad3813e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6e9c163506cf63ef32fae7ad3813e5">&#9670;&nbsp;</a></span>GradientTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GradientSignal::GradientTransform::GradientTransform </td>
          <td>(</td>
          <td class="paramtype">const AZ::Aabb &amp;&#160;</td>
          <td class="paramname"><em>shapeBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AZ::Matrix3x4 &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use3d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>frequencyZoom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GradientSignal::WrappingType&#160;</td>
          <td class="paramname"><em>wrappingType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="class_gradient_signal_1_1_gradient_transform.html">GradientTransform</a> with the given parameters. <a class="el" href="class_gradient_signal_1_1_gradient_transform.html">GradientTransform</a> is a utility class that converts world space positions to gradient space UVW values which can be used to look up deterministic gradient values for the input spatial locations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shapeBounds</td><td>The bounds of the shape associated with the gradient, in local space. </td></tr>
    <tr><td class="paramname">transform</td><td>The transform to use to convert from world space to gradient space. </td></tr>
    <tr><td class="paramname">use3d</td><td>True for 3D gradient lookup outputs, false for 2D gradient lookup outputs. (i.e. output W will be nonzero or zero) </td></tr>
    <tr><td class="paramname">frequencyZoom</td><td>Amount to scale the UVW results after wrapping is applied. </td></tr>
    <tr><td class="paramname">wrappingType</td><td>The way in which the gradient repeats itself outside the shape bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9c24eb157b31f188ccaf02148ea4999c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c24eb157b31f188ccaf02148ea4999c">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GradientSignal::GradientTransform::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gradient_signal_1_1_gradient_transform.html">GradientTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks to see if two <a class="el" href="class_gradient_signal_1_1_gradient_transform.html">GradientTransform</a> instances aren't equivalent. Useful for being able to send out notifications when a <a class="el" href="class_gradient_signal_1_1_gradient_transform.html">GradientTransform</a> has changed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The second GradientTranform to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if they're not equal, False if they are. </dd></dl>

</div>
</div>
<a id="a7534aaf61f2e8c5a2a094e263101413a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7534aaf61f2e8c5a2a094e263101413a">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GradientSignal::GradientTransform::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gradient_signal_1_1_gradient_transform.html">GradientTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks to see if two <a class="el" href="class_gradient_signal_1_1_gradient_transform.html">GradientTransform</a> instances are equivalent. <br  />
 Useful for being able to send out notifications when a <a class="el" href="class_gradient_signal_1_1_gradient_transform.html">GradientTransform</a> has changed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The second GradientTranform to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if they're equal, False if they aren't. </dd></dl>

</div>
</div>
<a id="a4f5a91cdc1619a4623e3fe416630e894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5a91cdc1619a4623e3fe416630e894">&#9670;&nbsp;</a></span>TransformPositionToUVW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GradientSignal::GradientTransform::TransformPositionToUVW </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>inPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>outUVW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>wasPointRejected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the given world space position to a gradient space UVW lookup value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inPosition</td><td>The input world space position to transform. </td></tr>
    <tr><td class="paramname">outUVW</td><td>[out] The UVW value that can be used to look up a deterministic gradient value. </td></tr>
    <tr><td class="paramname">wasPointRejected</td><td>[out] True if the input position doesn't have a gradient value, false if it does. Most gradients have values mapped to infinite world space, so wasPointRejected will almost always be false. It will only be true when using ClampToZero and the world space position falls outside the shape bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94e02576fc20963d69f03a02a88f66f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e02576fc20963d69f03a02a88f66f7">&#9670;&nbsp;</a></span>TransformPositionToUVWNormalized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GradientSignal::GradientTransform::TransformPositionToUVWNormalized </td>
          <td>(</td>
          <td class="paramtype">const AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>inPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZ::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>outUVW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>wasPointRejected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the given world space position to a gradient space UVW lookup value and normalize to the shape bounds. "Normalizing" in this context means that regardless of the world space coordinates, (0,0,0) represents the minimum shape bounds corner, and (1,1,1) represents the maximum shape bounds corner. Depending on the wrapping type, it's possible (and even likely) to get values outside the 0-1 range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inPosition</td><td>The input world space position to transform. </td></tr>
    <tr><td class="paramname">outUVW</td><td>[out] The UVW value that can be used to look up a deterministic gradient value. </td></tr>
    <tr><td class="paramname">wasPointRejected</td><td>[out] True if the input position doesn't have a gradient value, false if it does. Most gradients have values mapped to infinite world space, so wasPointRejected will almost always be false. It will only be true when using ClampToZero and the world space position falls outside the shape bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a805dfc248488ca5bb26a981a69d34265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805dfc248488ca5bb26a981a69d34265">&#9670;&nbsp;</a></span>UvEpsilon</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float GradientSignal::GradientTransform::UvEpsilon = 0.001f</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Epsilon value to allow our UVW range to go to [min, max) by using the range [min, max - epsilon]. To keep things behaving consistently between clamped and unbounded uv ranges, we want our clamped uvs to use a range of [min, max), so we'll actually clamp to [min, max - epsilon]. Since our floating-point numbers are likely in the -16384 to 16384 range, an epsilon of 0.001 will work without rounding to 0. (This constant is public so that it can be used from unit tests for validating transformation results) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Gems/GradientSignal/Code/Include/GradientSignal/GradientTransform.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 5 2022 15:19:47 for Open 3D Engine GradientSignal Gem API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
