<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine GridMate API Reference: GridMate::SocketDriverCommon Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="/images/api-reference/api-ref-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine GridMate API Reference
   &#160;<span id="projectnumber">2205.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_grid_mate.html">GridMate</a></li><li class="navelem"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html">SocketDriverCommon</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_grid_mate_1_1_socket_driver_common-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GridMate::SocketDriverCommon Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;SocketDriver.h&gt;</code></p>

<p>Inherits <a class="el" href="class_grid_mate_1_1_driver.html">GridMate::Driver</a>.</p>

<p>Inherited by <a class="el" href="class_grid_mate_1_1_socket_driver.html">GridMate::SocketDriver</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common_1_1_platform_socket_driver.html">PlatformSocketDriver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae37ff09cc30c40241faf9467f067f5e3"><td class="memItemLeft" align="right" valign="top"><a id="ae37ff09cc30c40241faf9467f067f5e3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SocketType</b> = Platform::SocketType_Platform</td></tr>
<tr class="separator:ae37ff09cc30c40241faf9467f067f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_grid_mate_1_1_driver"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_grid_mate_1_1_driver')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_grid_mate_1_1_driver.html">GridMate::Driver</a></td></tr>
<tr class="memitem:a26a34f51d6b6266fea4e32201b420a44 inherit pub_types_class_grid_mate_1_1_driver"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a26a34f51d6b6266fea4e32201b420a44">ErrorCodes</a> { <br />
&#160;&#160;<b>EC_OK</b> = 0, 
<b>EC_SOCKET_CREATE</b>, 
<b>EC_SOCKET_LISTEN</b>, 
<b>EC_SOCKET_CLOSE</b>, 
<br />
&#160;&#160;<b>EC_SOCKET_MAKE_NONBLOCK</b>, 
<b>EC_SOCKET_BIND</b>, 
<b>EC_SOCKET_SOCK_OPT</b>, 
<b>EC_SOCKET_CONNECT</b>, 
<br />
&#160;&#160;<b>EC_SOCKET_ACCEPT</b>, 
<b>EC_SECURE_CONFIG</b>, 
<b>EC_SECURE_CREATE</b>, 
<b>EC_SECURE_CERT</b>, 
<br />
&#160;&#160;<b>EC_SECURE_PKEY</b>, 
<b>EC_SECURE_CA_CERT</b>, 
<b>EC_SEND</b>, 
<a class="el" href="class_grid_mate_1_1_driver.html#a26a34f51d6b6266fea4e32201b420a44af4c945f84ffbd407ba50b1e2eb1969f8">EC_SEND_ADDRESS_NOT_BOUND</a>, 
<br />
&#160;&#160;<b>EC_RECEIVE</b>, 
<a class="el" href="class_grid_mate_1_1_driver.html#a26a34f51d6b6266fea4e32201b420a44aaad69d26cf855b3eb8236c481f8f6f60">EC_PLATFORM</a> = 1000, 
<b>EC_BUFFER_TOOLARGE</b> = 1001
<br />
 }</td></tr>
<tr class="separator:a26a34f51d6b6266fea4e32201b420a44 inherit pub_types_class_grid_mate_1_1_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc20591444dff5114cb4b0c5d52d481d inherit pub_types_class_grid_mate_1_1_driver"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#abc20591444dff5114cb4b0c5d52d481d">BSDSocketFamilyType</a> { <b>BSD_AF_INET</b> = 0, 
<b>BSD_AF_INET6</b>, 
<b>BSD_AF_UNSPEC</b>
 }</td></tr>
<tr class="separator:abc20591444dff5114cb4b0c5d52d481d inherit pub_types_class_grid_mate_1_1_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a694aee6a5384e4515b6891301759b inherit pub_types_class_grid_mate_1_1_driver"><td class="memItemLeft" align="right" valign="top"><a id="aa1a694aee6a5384e4515b6891301759b"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>ResultCode</b></td></tr>
<tr class="separator:aa1a694aee6a5384e4515b6891301759b inherit pub_types_class_grid_mate_1_1_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac4d2585959bde8a8dc5a3448f98977a3"><td class="memItemLeft" align="right" valign="top"><a id="ac4d2585959bde8a8dc5a3448f98977a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SocketDriverCommon</b> (bool isFullPackets=false, bool isCrossPlatform=false, bool isHighPerformance=false)</td></tr>
<tr class="separator:ac4d2585959bde8a8dc5a3448f98977a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4f0ea82220cf8ec3c8d5c11bd3cc70"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#adc4f0ea82220cf8ec3c8d5c11bd3cc70">GetMaxNumConnections</a> () const override</td></tr>
<tr class="memdesc:adc4f0ea82220cf8ec3c8d5c11bd3cc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum number of active connections at the same time.  <a href="class_grid_mate_1_1_socket_driver_common.html#adc4f0ea82220cf8ec3c8d5c11bd3cc70">More...</a><br /></td></tr>
<tr class="separator:adc4f0ea82220cf8ec3c8d5c11bd3cc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5700ac475af2a9b04d79b42b087d26ff"><td class="memItemLeft" align="right" valign="top"><a id="a5700ac475af2a9b04d79b42b087d26ff"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a5700ac475af2a9b04d79b42b087d26ff">GetMaxSendSize</a> () const override</td></tr>
<tr class="memdesc:a5700ac475af2a9b04d79b42b087d26ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum data size we can send/receive at once in bytes, supported by the platform. <br /></td></tr>
<tr class="separator:a5700ac475af2a9b04d79b42b087d26ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb86552b248a28414931811ebaf48f4a"><td class="memItemLeft" align="right" valign="top"><a id="aeb86552b248a28414931811ebaf48f4a"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#aeb86552b248a28414931811ebaf48f4a">GetPacketOverheadSize</a> () const override</td></tr>
<tr class="memdesc:aeb86552b248a28414931811ebaf48f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return packet overhead size in bytes. <br /></td></tr>
<tr class="separator:aeb86552b248a28414931811ebaf48f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec0cf696a869100bc5743e031c39eb8"><td class="memItemLeft" align="right" valign="top">ResultCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a7ec0cf696a869100bc5743e031c39eb8">Initialize</a> (int familyType=BSD_AF_INET, const char *address=nullptr, unsigned int port=0, bool isBroadcast=false, unsigned int receiveBufferSize=0, unsigned int sendBufferSize=0) override</td></tr>
<tr class="separator:a7ec0cf696a869100bc5743e031c39eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b1935ed374885626010d14ac9d7adf"><td class="memItemLeft" align="right" valign="top"><a id="a37b1935ed374885626010d14ac9d7adf"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a37b1935ed374885626010d14ac9d7adf">GetPort</a> () const override</td></tr>
<tr class="memdesc:a37b1935ed374885626010d14ac9d7adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns communication port (must be called after Initialize, otherwise it will return 0) <br /></td></tr>
<tr class="separator:a37b1935ed374885626010d14ac9d7adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee772c52ceac28e97d519de67c62f53"><td class="memItemLeft" align="right" valign="top"><a id="a6ee772c52ceac28e97d519de67c62f53"></a>
ResultCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a6ee772c52ceac28e97d519de67c62f53">Send</a> (const AZStd::intrusive_ptr&lt; <a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a> &gt; &amp;to, const char *data, unsigned int dataSize) override</td></tr>
<tr class="memdesc:a6ee772c52ceac28e97d519de67c62f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to a user defined address. <br /></td></tr>
<tr class="separator:a6ee772c52ceac28e97d519de67c62f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da1e62d7d3a0ba06fa952cd90ec6235"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a6da1e62d7d3a0ba06fa952cd90ec6235">Receive</a> (char *data, unsigned int maxDataSize, AZStd::intrusive_ptr&lt; <a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a> &gt; &amp;from, ResultCode *resultCode=0) override</td></tr>
<tr class="separator:a6da1e62d7d3a0ba06fa952cd90ec6235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40aab6eace5ad56fe0f163de005e6d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#ad40aab6eace5ad56fe0f163de005e6d3">WaitForData</a> (AZStd::chrono::microseconds timeOut=AZStd::chrono::microseconds(0)) override</td></tr>
<tr class="separator:ad40aab6eace5ad56fe0f163de005e6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c7c6833f61f8075ebe5d4aae52a523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a78c7c6833f61f8075ebe5d4aae52a523">StopWaitForData</a> () override</td></tr>
<tr class="separator:a78c7c6833f61f8075ebe5d4aae52a523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b07d6df08b9f5b23e2cdad64628233a"><td class="memItemLeft" align="right" valign="top"><a id="a7b07d6df08b9f5b23e2cdad64628233a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a7b07d6df08b9f5b23e2cdad64628233a">WasStopeedWaitingForData</a> () override</td></tr>
<tr class="memdesc:a7b07d6df08b9f5b23e2cdad64628233a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if WaitForData was interrupted before the timeOut expired, otherwise false. <br /></td></tr>
<tr class="separator:a7b07d6df08b9f5b23e2cdad64628233a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650b15a8aa60284822b342c728a9e1b4"><td class="memItemLeft" align="right" valign="top">AZStd::intrusive_ptr&lt; <a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a650b15a8aa60284822b342c728a9e1b4">CreateDriverAddress</a> (const AZStd::string &amp;address) override=0</td></tr>
<tr class="separator:a650b15a8aa60284822b342c728a9e1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea42bef835b384f9ba424d0437aa26c"><td class="memItemLeft" align="right" valign="top"><a id="a5ea42bef835b384f9ba424d0437aa26c"></a>
virtual AZStd::intrusive_ptr&lt; <a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a5ea42bef835b384f9ba424d0437aa26c">CreateDriverAddress</a> (const sockaddr *sockAddr)=0</td></tr>
<tr class="memdesc:a5ea42bef835b384f9ba424d0437aa26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional CreateDriverAddress function should be implemented. <br /></td></tr>
<tr class="separator:a5ea42bef835b384f9ba424d0437aa26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_grid_mate_1_1_driver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_grid_mate_1_1_driver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_grid_mate_1_1_driver.html">GridMate::Driver</a></td></tr>
<tr class="memitem:a6e1cad8035b10fdd6613585ef7a375b3 inherit pub_methods_class_grid_mate_1_1_driver"><td class="memItemLeft" align="right" valign="top"><a id="a6e1cad8035b10fdd6613585ef7a375b3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Update</b> ()</td></tr>
<tr class="separator:a6e1cad8035b10fdd6613585ef7a375b3 inherit pub_methods_class_grid_mate_1_1_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe0472881c3f77e70df77a0763d1604 inherit pub_methods_class_grid_mate_1_1_driver"><td class="memItemLeft" align="right" valign="top"><a id="afbe0472881c3f77e70df77a0763d1604"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessIncoming</b> ()</td></tr>
<tr class="separator:afbe0472881c3f77e70df77a0763d1604 inherit pub_methods_class_grid_mate_1_1_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d8b8ffb13ed52097c6d746f6aed22e inherit pub_methods_class_grid_mate_1_1_driver"><td class="memItemLeft" align="right" valign="top"><a id="ad4d8b8ffb13ed52097c6d746f6aed22e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessOutgoing</b> ()</td></tr>
<tr class="separator:ad4d8b8ffb13ed52097c6d746f6aed22e inherit pub_methods_class_grid_mate_1_1_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2a7d1125cef23fc0cd1701aa5c2da2 inherit pub_methods_class_grid_mate_1_1_driver"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a1f2a7d1125cef23fc0cd1701aa5c2da2">CanSend</a> () const</td></tr>
<tr class="separator:a1f2a7d1125cef23fc0cd1701aa5c2da2 inherit pub_methods_class_grid_mate_1_1_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac542c17046fb9129a39912e9a451cf05"><td class="memItemLeft" align="right" valign="top"><a id="ac542c17046fb9129a39912e9a451cf05"></a>
virtual SocketType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#ac542c17046fb9129a39912e9a451cf05">CreateSocket</a> (int af, int type, int protocol)</td></tr>
<tr class="memdesc:ac542c17046fb9129a39912e9a451cf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns result of socket(af,type,protocol) <br /></td></tr>
<tr class="separator:ac542c17046fb9129a39912e9a451cf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f06cb8aec0e24e516765aa0bc88ac02"><td class="memItemLeft" align="right" valign="top"><a id="a8f06cb8aec0e24e516765aa0bc88ac02"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a8f06cb8aec0e24e516765aa0bc88ac02">BindSocket</a> (const sockaddr *sockAddr, size_t sockAddrLen)</td></tr>
<tr class="memdesc:a8f06cb8aec0e24e516765aa0bc88ac02"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the result of bind(sockAddr) <br /></td></tr>
<tr class="separator:a8f06cb8aec0e24e516765aa0bc88ac02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb134a78d7be2cb7c55235fa2972925d"><td class="memItemLeft" align="right" valign="top"><a id="aeb134a78d7be2cb7c55235fa2972925d"></a>
virtual ResultCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#aeb134a78d7be2cb7c55235fa2972925d">SetSocketOptions</a> (bool isBroadcast, unsigned int receiveBufferSize, unsigned int sendBufferSize)</td></tr>
<tr class="memdesc:aeb134a78d7be2cb7c55235fa2972925d"><td class="mdescLeft">&#160;</td><td class="mdescRight">set's default socket options <br /></td></tr>
<tr class="separator:aeb134a78d7be2cb7c55235fa2972925d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_grid_mate_1_1_driver"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_grid_mate_1_1_driver')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_grid_mate_1_1_driver.html">GridMate::Driver</a></td></tr>
<tr class="memitem:a199a416ab78e917cef3475c477db1469 inherit pro_methods_class_grid_mate_1_1_driver"><td class="memItemLeft" align="right" valign="top"><a id="a199a416ab78e917cef3475c477db1469"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>DestroyDriverAddress</b> (<a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a> *address)=0</td></tr>
<tr class="separator:a199a416ab78e917cef3475c477db1469 inherit pro_methods_class_grid_mate_1_1_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8db3aae8f88e064a51b092d3ec7fe666"><td class="memItemLeft" align="right" valign="top"><a id="a8db3aae8f88e064a51b092d3ec7fe666"></a>
SocketType&#160;</td><td class="memItemRight" valign="bottom"><b>m_socket</b></td></tr>
<tr class="separator:a8db3aae8f88e064a51b092d3ec7fe666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5eae08a11cd01382e97f756af4c4b3d"><td class="memItemLeft" align="right" valign="top"><a id="aa5eae08a11cd01382e97f756af4c4b3d"></a>
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>m_port</b></td></tr>
<tr class="separator:aa5eae08a11cd01382e97f756af4c4b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d18d42ffdeaaececa65a7eed8b5cc5"><td class="memItemLeft" align="right" valign="top"><a id="ab9d18d42ffdeaaececa65a7eed8b5cc5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#ab9d18d42ffdeaaececa65a7eed8b5cc5">m_isStoppedWaitForData</a></td></tr>
<tr class="memdesc:ab9d18d42ffdeaaececa65a7eed8b5cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if last WaitForData was interrupted otherwise false. <br /></td></tr>
<tr class="separator:ab9d18d42ffdeaaececa65a7eed8b5cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2899ca9fff8f44b39b366bb132a054a6"><td class="memItemLeft" align="right" valign="top"><a id="a2899ca9fff8f44b39b366bb132a054a6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a2899ca9fff8f44b39b366bb132a054a6">m_isFullPackets</a></td></tr>
<tr class="memdesc:a2899ca9fff8f44b39b366bb132a054a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if we use max packet size vs internet safe packet size (64KB vs 1500 usually) <br /></td></tr>
<tr class="separator:a2899ca9fff8f44b39b366bb132a054a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dab985359eaab01f86074ffd01bbb2b"><td class="memItemLeft" align="right" valign="top"><a id="a8dab985359eaab01f86074ffd01bbb2b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a8dab985359eaab01f86074ffd01bbb2b">m_isCrossPlatform</a></td></tr>
<tr class="memdesc:a8dab985359eaab01f86074ffd01bbb2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if we support cross platform communication. Then we make sure we use common features. <br /></td></tr>
<tr class="separator:a8dab985359eaab01f86074ffd01bbb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a1d0124ea3800b0fd98144dd263e13"><td class="memItemLeft" align="right" valign="top"><a id="a11a1d0124ea3800b0fd98144dd263e13"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a11a1d0124ea3800b0fd98144dd263e13">m_isIpv6</a></td></tr>
<tr class="memdesc:a11a1d0124ea3800b0fd98144dd263e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if we use version 6 of the internet protocol, otherwise false. <br /></td></tr>
<tr class="separator:a11a1d0124ea3800b0fd98144dd263e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71cd5c17a2962a6c2a2a56a9b626118"><td class="memItemLeft" align="right" valign="top"><a id="ad71cd5c17a2962a6c2a2a56a9b626118"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#ad71cd5c17a2962a6c2a2a56a9b626118">m_isDatagram</a></td></tr>
<tr class="memdesc:ad71cd5c17a2962a6c2a2a56a9b626118"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the socket was created with SOCK_DGRAM. <br /></td></tr>
<tr class="separator:ad71cd5c17a2962a6c2a2a56a9b626118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e1bc78ee152cb2e0e703948bd2b45a"><td class="memItemLeft" align="right" valign="top"><a id="a72e1bc78ee152cb2e0e703948bd2b45a"></a>
AZStd::unique_ptr&lt; <a class="el" href="class_grid_mate_1_1_socket_driver_common_1_1_platform_socket_driver.html">PlatformSocketDriver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a72e1bc78ee152cb2e0e703948bd2b45a">m_platformDriver</a></td></tr>
<tr class="memdesc:a72e1bc78ee152cb2e0e703948bd2b45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform specific implementation of socket calls. <br /></td></tr>
<tr class="separator:a72e1bc78ee152cb2e0e703948bd2b45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e868d3673468abf77ad4463e846a89"><td class="memItemLeft" align="right" valign="top"><a id="a52e868d3673468abf77ad4463e846a89"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a52e868d3673468abf77ad4463e846a89">m_isHighPerformance</a></td></tr>
<tr class="memdesc:a52e868d3673468abf77ad4463e846a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if using platform-specific high-performance implementation. <br /></td></tr>
<tr class="separator:a52e868d3673468abf77ad4463e846a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_grid_mate_1_1_driver"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_grid_mate_1_1_driver')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_grid_mate_1_1_driver.html">GridMate::Driver</a></td></tr>
<tr class="memitem:a6b72b391810f9c12682f89ef25789ef8 inherit pro_attribs_class_grid_mate_1_1_driver"><td class="memItemLeft" align="right" valign="top"><a id="a6b72b391810f9c12682f89ef25789ef8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a6b72b391810f9c12682f89ef25789ef8">m_canSend</a></td></tr>
<tr class="memdesc:a6b72b391810f9c12682f89ef25789ef8 inherit pro_attribs_class_grid_mate_1_1_driver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can the driver accept more data. <br /></td></tr>
<tr class="separator:a6b72b391810f9c12682f89ef25789ef8 inherit pro_attribs_class_grid_mate_1_1_driver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063f155171d4cd0a0833cf62742b687d"><td class="memItemLeft" align="right" valign="top">AZStd::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a063f155171d4cd0a0833cf62742b687d">IPPortToAddress</a> (const char *ip, unsigned int port) const override</td></tr>
<tr class="separator:a063f155171d4cd0a0833cf62742b687d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77324bfbc8c263fe3feeed9d4098fbed"><td class="memItemLeft" align="right" valign="top"><a id="a77324bfbc8c263fe3feeed9d4098fbed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>AddressToIPPort</b> (const AZStd::string &amp;address, AZStd::string &amp;ip, unsigned int &amp;port) const override</td></tr>
<tr class="separator:a77324bfbc8c263fe3feeed9d4098fbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21054fd03488c31b19f9292e5ef9dec"><td class="memItemLeft" align="right" valign="top"><a id="ae21054fd03488c31b19f9292e5ef9dec"></a>
static AZStd::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#ae21054fd03488c31b19f9292e5ef9dec">IPPortToAddressString</a> (const char *ip, unsigned int port)</td></tr>
<tr class="memdesc:ae21054fd03488c31b19f9292e5ef9dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create address for the socket driver from IP and port. <br /></td></tr>
<tr class="separator:ae21054fd03488c31b19f9292e5ef9dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7872d013b845431a7b8b07eb75ec48a9"><td class="memItemLeft" align="right" valign="top"><a id="a7872d013b845431a7b8b07eb75ec48a9"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a7872d013b845431a7b8b07eb75ec48a9">AddressStringToIPPort</a> (const AZStd::string &amp;address, AZStd::string &amp;ip, unsigned int &amp;port)</td></tr>
<tr class="memdesc:a7872d013b845431a7b8b07eb75ec48a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose an address to IP and port. <br /></td></tr>
<tr class="separator:a7872d013b845431a7b8b07eb75ec48a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcf4b0efc9b463d17f56f672698cf84"><td class="memItemLeft" align="right" valign="top"><a id="a9fcf4b0efc9b463d17f56f672698cf84"></a>
static <a class="el" href="class_grid_mate_1_1_driver.html#abc20591444dff5114cb4b0c5d52d481d">BSDSocketFamilyType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a9fcf4b0efc9b463d17f56f672698cf84">AddressFamilyType</a> (const AZStd::string &amp;ip)</td></tr>
<tr class="memdesc:a9fcf4b0efc9b463d17f56f672698cf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the family type of the address (AF_INET,AF_INET6 AF_UNSPEC) <br /></td></tr>
<tr class="separator:a9fcf4b0efc9b463d17f56f672698cf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cca2a71132e21ab13ed0357c0e0ea8"><td class="memItemLeft" align="right" valign="top"><a id="a05cca2a71132e21ab13ed0357c0e0ea8"></a>
static <a class="el" href="class_grid_mate_1_1_driver.html#abc20591444dff5114cb4b0c5d52d481d">BSDSocketFamilyType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AddressFamilyType</b> (const char *ip)</td></tr>
<tr class="separator:a05cca2a71132e21ab13ed0357c0e0ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base common class for all SocketBased drivers, you can't NOT create an instance of the <a class="el" href="class_grid_mate_1_1_socket_driver_common.html">SocketDriverCommon</a> use CreateSocketDriver function for a BSD socket driver. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a650b15a8aa60284822b342c728a9e1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650b15a8aa60284822b342c728a9e1b4">&#9670;&nbsp;</a></span>CreateDriverAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AZStd::intrusive_ptr&lt;<a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a>&gt; GridMate::SocketDriverCommon::CreateDriverAddress </td>
          <td>(</td>
          <td class="paramtype">const AZStd::string &amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates internal driver address to be used for send/receive calls. </p><dl class="section note"><dt>Note</dt><dd>if the ip and the port are the same, the same pointer will be returned. You can use the returned pointer to compare for unique addresses. </dd>
<dd>
<a class="el" href="class_grid_mate_1_1_driver.html">Driver</a> address allocates internal resources, use it only when you intend to communicate. Otherwise operate with the string address. </dd></dl>

<p>Implements <a class="el" href="class_grid_mate_1_1_driver.html#a20b42c7ea6e07e0f7b416ee821a92092">GridMate::Driver</a>.</p>

<p>Implemented in <a class="el" href="class_grid_mate_1_1_socket_driver.html#a4963d7850dfda5f1630cd971457dc80a">GridMate::SocketDriver</a>.</p>

</div>
</div>
<a id="adc4f0ea82220cf8ec3c8d5c11bd3cc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4f0ea82220cf8ec3c8d5c11bd3cc70">&#9670;&nbsp;</a></span>GetMaxNumConnections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GridMate::SocketDriverCommon::GetMaxNumConnections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return maximum number of active connections at the same time. </p>
<p>Platform specific functionality. </p>

<p>Implements <a class="el" href="class_grid_mate_1_1_driver.html#a9ec21ad0c39985e795e5ed357df11577">GridMate::Driver</a>.</p>

<p>Reimplemented in <a class="el" href="class_grid_mate_1_1_stream_socket_driver.html#a1ac4fcbb062fd5e8f875af9258079570">GridMate::StreamSocketDriver</a>.</p>

</div>
</div>
<a id="a7ec0cf696a869100bc5743e031c39eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec0cf696a869100bc5743e031c39eb8">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultCode GridMate::SocketDriverCommon::Initialize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>familyType</em> = <code>BSD_AF_INET</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBroadcast</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>receiveBufferSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sendBufferSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>User should implement create and bind a UDP socket. This socket will be used for all communications. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ft</td><td>family type, for the BSD socket it can be AFT_IPV4 or AFT_IPV6. </td></tr>
    <tr><td class="paramname">address</td><td>when 0 it we will assume "any address". </td></tr>
    <tr><td class="paramname">port</td><td>When left 0, we use implicit bind (assigned by the system). Otherwise provide a valid port number. </td></tr>
    <tr><td class="paramname">isBroadcast</td><td>is valid for Ipv4 only (otherwise ignored). Sets the socket to support broadcasts. </td></tr>
    <tr><td class="paramname">receiveBufferSize</td><td>socket receive buffer size in bytes, use 0 for default values. </td></tr>
    <tr><td class="paramname">sendBufferSize</td><td>socket send buffer size, use 0 for default values. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_grid_mate_1_1_driver.html#acede1e32eb9a7e3039c0322a32042d45">GridMate::Driver</a>.</p>

</div>
</div>
<a id="a063f155171d4cd0a0833cf62742b687d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063f155171d4cd0a0833cf62742b687d">&#9670;&nbsp;</a></span>IPPortToAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AZStd::string GridMate::SocketDriverCommon::IPPortToAddress </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Address conversion functionality. They MUST implemented thread safe. Generally this is not a problem since they just part local data. Create address from ip and port. If ip == NULL we will assign a broadcast address. </p>

<p>Implements <a class="el" href="class_grid_mate_1_1_driver.html#adcb8ee83801ec6a44035174ab8d2ca31">GridMate::Driver</a>.</p>

</div>
</div>
<a id="a6da1e62d7d3a0ba06fa952cd90ec6235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da1e62d7d3a0ba06fa952cd90ec6235">&#9670;&nbsp;</a></span>Receive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GridMate::SocketDriverCommon::Receive </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZStd::intrusive_ptr&lt; <a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultCode *&#160;</td>
          <td class="paramname"><em>resultCode</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Receives a datagram and stores the source address. maxDataSize must be &gt;= than <a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a5700ac475af2a9b04d79b42b087d26ff" title="Return maximum data size we can send/receive at once in bytes, supported by the platform.">GetMaxSendSize()</a>. Returns the num of of received bytes. </p><dl class="section note"><dt>Note</dt><dd>If a datagram from a new connection is received, NewConnectionCB will be called. If it rejects the connection the returned from pointer will be NULL while the actual data will be returned. </dd></dl>

<p>Implements <a class="el" href="class_grid_mate_1_1_driver.html#a97e3d677fc1129f28ac1483ef8ccff48">GridMate::Driver</a>.</p>

</div>
</div>
<a id="a78c7c6833f61f8075ebe5d4aae52a523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c7c6833f61f8075ebe5d4aae52a523">&#9670;&nbsp;</a></span>StopWaitForData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GridMate::SocketDriverCommon::StopWaitForData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When you enter wait for data mode, for many reasons you might want to stop wait for data. If you implement this function you need to make sure it's a thread safe function. </p>

<p>Implements <a class="el" href="class_grid_mate_1_1_driver.html#a58ee4389496dfe5c16d83d1bcd23e982">GridMate::Driver</a>.</p>

</div>
</div>
<a id="ad40aab6eace5ad56fe0f163de005e6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40aab6eace5ad56fe0f163de005e6d3">&#9670;&nbsp;</a></span>WaitForData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GridMate::SocketDriverCommon::WaitForData </td>
          <td>(</td>
          <td class="paramtype">AZStd::chrono::microseconds&#160;</td>
          <td class="paramname"><em>timeOut</em> = <code>AZStd::chrono::microseconds(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait for data to be to the ready for receive. Time out is the maximum time to wait before this function returns. If left to default value it will be in blocking mode (wait until data is ready to be received). </p><dl class="section return"><dt>Returns</dt><dd>true if there is data to be received (always true if timeOut == 0), otherwise false. </dd></dl>

<p>Implements <a class="el" href="class_grid_mate_1_1_driver.html#a1409b151a8b03054434fa8d923c75f07">GridMate::Driver</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Code/Framework/GridMate/GridMate/Carrier/SocketDriver.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 5 2022 15:18:29 for Open 3D Engine GridMate API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
