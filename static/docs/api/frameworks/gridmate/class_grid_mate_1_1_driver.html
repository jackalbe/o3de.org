<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open 3D Engine GridMate API Reference: GridMate::Driver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="/images/api-reference/api-ref-icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine GridMate API Reference
   &#160;<span id="projectnumber">2205.0</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_grid_mate.html">GridMate</a></li><li class="navelem"><a class="el" href="class_grid_mate_1_1_driver.html">Driver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_grid_mate_1_1_driver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GridMate::Driver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Driver.h&gt;</code></p>

<p>Inherited by <a class="el" href="class_grid_mate_1_1_socket_driver_common.html">GridMate::SocketDriverCommon</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a26a34f51d6b6266fea4e32201b420a44"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a26a34f51d6b6266fea4e32201b420a44">ErrorCodes</a> { <br />
&#160;&#160;<b>EC_OK</b> = 0, 
<b>EC_SOCKET_CREATE</b>, 
<b>EC_SOCKET_LISTEN</b>, 
<b>EC_SOCKET_CLOSE</b>, 
<br />
&#160;&#160;<b>EC_SOCKET_MAKE_NONBLOCK</b>, 
<b>EC_SOCKET_BIND</b>, 
<b>EC_SOCKET_SOCK_OPT</b>, 
<b>EC_SOCKET_CONNECT</b>, 
<br />
&#160;&#160;<b>EC_SOCKET_ACCEPT</b>, 
<b>EC_SECURE_CONFIG</b>, 
<b>EC_SECURE_CREATE</b>, 
<b>EC_SECURE_CERT</b>, 
<br />
&#160;&#160;<b>EC_SECURE_PKEY</b>, 
<b>EC_SECURE_CA_CERT</b>, 
<b>EC_SEND</b>, 
<a class="el" href="class_grid_mate_1_1_driver.html#a26a34f51d6b6266fea4e32201b420a44af4c945f84ffbd407ba50b1e2eb1969f8">EC_SEND_ADDRESS_NOT_BOUND</a>, 
<br />
&#160;&#160;<b>EC_RECEIVE</b>, 
<a class="el" href="class_grid_mate_1_1_driver.html#a26a34f51d6b6266fea4e32201b420a44aaad69d26cf855b3eb8236c481f8f6f60">EC_PLATFORM</a> = 1000, 
<b>EC_BUFFER_TOOLARGE</b> = 1001
<br />
 }</td></tr>
<tr class="separator:a26a34f51d6b6266fea4e32201b420a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc20591444dff5114cb4b0c5d52d481d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#abc20591444dff5114cb4b0c5d52d481d">BSDSocketFamilyType</a> { <b>BSD_AF_INET</b> = 0, 
<b>BSD_AF_INET6</b>, 
<b>BSD_AF_UNSPEC</b>
 }</td></tr>
<tr class="separator:abc20591444dff5114cb4b0c5d52d481d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a694aee6a5384e4515b6891301759b"><td class="memItemLeft" align="right" valign="top"><a id="aa1a694aee6a5384e4515b6891301759b"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>ResultCode</b></td></tr>
<tr class="separator:aa1a694aee6a5384e4515b6891301759b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6e1cad8035b10fdd6613585ef7a375b3"><td class="memItemLeft" align="right" valign="top"><a id="a6e1cad8035b10fdd6613585ef7a375b3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>Update</b> ()</td></tr>
<tr class="separator:a6e1cad8035b10fdd6613585ef7a375b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe0472881c3f77e70df77a0763d1604"><td class="memItemLeft" align="right" valign="top"><a id="afbe0472881c3f77e70df77a0763d1604"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessIncoming</b> ()</td></tr>
<tr class="separator:afbe0472881c3f77e70df77a0763d1604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d8b8ffb13ed52097c6d746f6aed22e"><td class="memItemLeft" align="right" valign="top"><a id="ad4d8b8ffb13ed52097c6d746f6aed22e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>ProcessOutgoing</b> ()</td></tr>
<tr class="separator:ad4d8b8ffb13ed52097c6d746f6aed22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec21ad0c39985e795e5ed357df11577"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a9ec21ad0c39985e795e5ed357df11577">GetMaxNumConnections</a> () const =0</td></tr>
<tr class="memdesc:a9ec21ad0c39985e795e5ed357df11577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum number of active connections at the same time.  <a href="class_grid_mate_1_1_driver.html#a9ec21ad0c39985e795e5ed357df11577">More...</a><br /></td></tr>
<tr class="separator:a9ec21ad0c39985e795e5ed357df11577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895218e87b2ac7f34be60e429c4e39a5"><td class="memItemLeft" align="right" valign="top"><a id="a895218e87b2ac7f34be60e429c4e39a5"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a895218e87b2ac7f34be60e429c4e39a5">GetMaxSendSize</a> () const =0</td></tr>
<tr class="memdesc:a895218e87b2ac7f34be60e429c4e39a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum data size we can send/receive at once in bytes, supported by the platform. <br /></td></tr>
<tr class="separator:a895218e87b2ac7f34be60e429c4e39a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cdfa3de3e9e7321d895baeef190822"><td class="memItemLeft" align="right" valign="top"><a id="a28cdfa3de3e9e7321d895baeef190822"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a28cdfa3de3e9e7321d895baeef190822">GetPacketOverheadSize</a> () const</td></tr>
<tr class="memdesc:a28cdfa3de3e9e7321d895baeef190822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return packet overhead size in bytes. <br /></td></tr>
<tr class="separator:a28cdfa3de3e9e7321d895baeef190822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acede1e32eb9a7e3039c0322a32042d45"><td class="memItemLeft" align="right" valign="top">virtual ResultCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#acede1e32eb9a7e3039c0322a32042d45">Initialize</a> (int familyType=0, const char *address=nullptr, unsigned int port=0, bool isBroadcast=false, unsigned int receiveBufferSize=0, unsigned int sendBufferSize=0)=0</td></tr>
<tr class="memdesc:acede1e32eb9a7e3039c0322a32042d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms an error code to string.  <a href="class_grid_mate_1_1_driver.html#acede1e32eb9a7e3039c0322a32042d45">More...</a><br /></td></tr>
<tr class="separator:acede1e32eb9a7e3039c0322a32042d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a7bbb9c30aa984546564e07e90f62b"><td class="memItemLeft" align="right" valign="top"><a id="a44a7bbb9c30aa984546564e07e90f62b"></a>
virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a44a7bbb9c30aa984546564e07e90f62b">GetPort</a> () const =0</td></tr>
<tr class="memdesc:a44a7bbb9c30aa984546564e07e90f62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns communication port (must be called after Initialize, otherwise it will return 0) <br /></td></tr>
<tr class="separator:a44a7bbb9c30aa984546564e07e90f62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d2e7d2acc7dc0d14b196ac68f20ff0"><td class="memItemLeft" align="right" valign="top"><a id="af4d2e7d2acc7dc0d14b196ac68f20ff0"></a>
virtual ResultCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#af4d2e7d2acc7dc0d14b196ac68f20ff0">Send</a> (const AZStd::intrusive_ptr&lt; <a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a> &gt; &amp;to, const char *data, unsigned int dataSize)=0</td></tr>
<tr class="memdesc:af4d2e7d2acc7dc0d14b196ac68f20ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to a user defined address. <br /></td></tr>
<tr class="separator:af4d2e7d2acc7dc0d14b196ac68f20ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e3d677fc1129f28ac1483ef8ccff48"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a97e3d677fc1129f28ac1483ef8ccff48">Receive</a> (char *data, unsigned int maxDataSize, AZStd::intrusive_ptr&lt; <a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a> &gt; &amp;from, ResultCode *resultCode=0)=0</td></tr>
<tr class="separator:a97e3d677fc1129f28ac1483ef8ccff48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1409b151a8b03054434fa8d923c75f07"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a1409b151a8b03054434fa8d923c75f07">WaitForData</a> (AZStd::chrono::microseconds timeOut=AZStd::chrono::microseconds(0))=0</td></tr>
<tr class="separator:a1409b151a8b03054434fa8d923c75f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ee4389496dfe5c16d83d1bcd23e982"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a58ee4389496dfe5c16d83d1bcd23e982">StopWaitForData</a> ()=0</td></tr>
<tr class="separator:a58ee4389496dfe5c16d83d1bcd23e982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b358d3dda32d1c12c14d13e950e8f5"><td class="memItemLeft" align="right" valign="top"><a id="a43b358d3dda32d1c12c14d13e950e8f5"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a43b358d3dda32d1c12c14d13e950e8f5">WasStopeedWaitingForData</a> ()=0</td></tr>
<tr class="memdesc:a43b358d3dda32d1c12c14d13e950e8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if WaitForData was interrupted before the timeOut expired, otherwise false. <br /></td></tr>
<tr class="separator:a43b358d3dda32d1c12c14d13e950e8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b42c7ea6e07e0f7b416ee821a92092"><td class="memItemLeft" align="right" valign="top">virtual AZStd::intrusive_ptr&lt; <a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a20b42c7ea6e07e0f7b416ee821a92092">CreateDriverAddress</a> (const AZStd::string &amp;address)=0</td></tr>
<tr class="separator:a20b42c7ea6e07e0f7b416ee821a92092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2a7d1125cef23fc0cd1701aa5c2da2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a1f2a7d1125cef23fc0cd1701aa5c2da2">CanSend</a> () const</td></tr>
<tr class="separator:a1f2a7d1125cef23fc0cd1701aa5c2da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adcb8ee83801ec6a44035174ab8d2ca31"><td class="memItemLeft" align="right" valign="top">virtual AZStd::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#adcb8ee83801ec6a44035174ab8d2ca31">IPPortToAddress</a> (const char *ip, unsigned int port) const =0</td></tr>
<tr class="separator:adcb8ee83801ec6a44035174ab8d2ca31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6394ea081f0f865ca0e524e0a3aa6571"><td class="memItemLeft" align="right" valign="top"><a id="a6394ea081f0f865ca0e524e0a3aa6571"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>AddressToIPPort</b> (const AZStd::string &amp;address, AZStd::string &amp;ip, unsigned int &amp;port) const =0</td></tr>
<tr class="separator:a6394ea081f0f865ca0e524e0a3aa6571"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a199a416ab78e917cef3475c477db1469"><td class="memItemLeft" align="right" valign="top"><a id="a199a416ab78e917cef3475c477db1469"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>DestroyDriverAddress</b> (<a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a> *address)=0</td></tr>
<tr class="separator:a199a416ab78e917cef3475c477db1469"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6b72b391810f9c12682f89ef25789ef8"><td class="memItemLeft" align="right" valign="top"><a id="a6b72b391810f9c12682f89ef25789ef8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grid_mate_1_1_driver.html#a6b72b391810f9c12682f89ef25789ef8">m_canSend</a></td></tr>
<tr class="memdesc:a6b72b391810f9c12682f89ef25789ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can the driver accept more data. <br /></td></tr>
<tr class="separator:a6b72b391810f9c12682f89ef25789ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1a0da3130aa9b564c24bda1800d46452"><td class="memItemLeft" align="right" valign="top"><a id="a1a0da3130aa9b564c24bda1800d46452"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DriverAddress</b></td></tr>
<tr class="separator:a1a0da3130aa9b564c24bda1800d46452"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_grid_mate_1_1_driver.html">Driver</a> interface is the interface for the lowest level of the transport layer. </p><dl class="section note"><dt>Note</dt><dd>All the code is executed in a thread context! Any interaction with the outside code should be made thread safe. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="abc20591444dff5114cb4b0c5d52d481d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc20591444dff5114cb4b0c5d52d481d">&#9670;&nbsp;</a></span>BSDSocketFamilyType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_grid_mate_1_1_driver.html#abc20591444dff5114cb4b0c5d52d481d">GridMate::Driver::BSDSocketFamilyType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Family types for BSD socket. </p>

</div>
</div>
<a id="a26a34f51d6b6266fea4e32201b420a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a34f51d6b6266fea4e32201b420a44">&#9670;&nbsp;</a></span>ErrorCodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_grid_mate_1_1_driver.html#a26a34f51d6b6266fea4e32201b420a44">GridMate::Driver::ErrorCodes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a26a34f51d6b6266fea4e32201b420a44af4c945f84ffbd407ba50b1e2eb1969f8"></a>EC_SEND_ADDRESS_NOT_BOUND&#160;</td><td class="fielddoc"><p>We failed to send because the remote address was NOT bound. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26a34f51d6b6266fea4e32201b420a44aaad69d26cf855b3eb8236c481f8f6f60"></a>EC_PLATFORM&#160;</td><td class="fielddoc"><p>use codes above 1000 for platform specific error codes </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1f2a7d1125cef23fc0cd1701aa5c2da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2a7d1125cef23fc0cd1701aa5c2da2">&#9670;&nbsp;</a></span>CanSend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GridMate::Driver::CanSend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the driver can accept new data (ex, has buffer space). </p>

</div>
</div>
<a id="a20b42c7ea6e07e0f7b416ee821a92092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b42c7ea6e07e0f7b416ee821a92092">&#9670;&nbsp;</a></span>CreateDriverAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AZStd::intrusive_ptr&lt;<a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a>&gt; GridMate::Driver::CreateDriverAddress </td>
          <td>(</td>
          <td class="paramtype">const AZStd::string &amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates internal driver address to be used for send/receive calls. </p><dl class="section note"><dt>Note</dt><dd>if the ip and the port are the same, the same pointer will be returned. You can use the returned pointer to compare for unique addresses. </dd>
<dd>
<a class="el" href="class_grid_mate_1_1_driver.html">Driver</a> address allocates internal resources, use it only when you intend to communicate. Otherwise operate with the string address. </dd></dl>

<p>Implemented in <a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a650b15a8aa60284822b342c728a9e1b4">GridMate::SocketDriverCommon</a>, and <a class="el" href="class_grid_mate_1_1_socket_driver.html#a4963d7850dfda5f1630cd971457dc80a">GridMate::SocketDriver</a>.</p>

</div>
</div>
<a id="a9ec21ad0c39985e795e5ed357df11577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec21ad0c39985e795e5ed357df11577">&#9670;&nbsp;</a></span>GetMaxNumConnections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int GridMate::Driver::GetMaxNumConnections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return maximum number of active connections at the same time. </p>
<p>Platform specific functionality. </p>

<p>Implemented in <a class="el" href="class_grid_mate_1_1_socket_driver_common.html#adc4f0ea82220cf8ec3c8d5c11bd3cc70">GridMate::SocketDriverCommon</a>, and <a class="el" href="class_grid_mate_1_1_stream_socket_driver.html#a1ac4fcbb062fd5e8f875af9258079570">GridMate::StreamSocketDriver</a>.</p>

</div>
</div>
<a id="acede1e32eb9a7e3039c0322a32042d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acede1e32eb9a7e3039c0322a32042d45">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ResultCode GridMate::Driver::Initialize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>familyType</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBroadcast</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>receiveBufferSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sendBufferSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms an error code to string. </p>
<p>User should implement create and bind a UDP socket. This socket will be used for all communications. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ft</td><td>family type (this value depends on the platform), 0 will use the default family type (for BSD socket this is ipv4) </td></tr>
    <tr><td class="paramname">address</td><td>when 0 it we will assume "any address". </td></tr>
    <tr><td class="paramname">port</td><td>When left 0, we use implicit bind (assigned by the system). Otherwise provide a valid port number. </td></tr>
    <tr><td class="paramname">receiveBufferSize</td><td>socket receive buffer size in bytes, use 0 for default values. </td></tr>
    <tr><td class="paramname">sendBufferSize</td><td>socket send buffer size, use 0 for default values. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a7ec0cf696a869100bc5743e031c39eb8">GridMate::SocketDriverCommon</a>.</p>

</div>
</div>
<a id="adcb8ee83801ec6a44035174ab8d2ca31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb8ee83801ec6a44035174ab8d2ca31">&#9670;&nbsp;</a></span>IPPortToAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual AZStd::string GridMate::Driver::IPPortToAddress </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Address conversion functionality. They MUST implemented thread safe. Generally this is not a problem since they just part local data. Create address from ip and port. If ip == NULL we will assign a broadcast address. </p>

<p>Implemented in <a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a063f155171d4cd0a0833cf62742b687d">GridMate::SocketDriverCommon</a>.</p>

</div>
</div>
<a id="a97e3d677fc1129f28ac1483ef8ccff48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e3d677fc1129f28ac1483ef8ccff48">&#9670;&nbsp;</a></span>Receive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int GridMate::Driver::Receive </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AZStd::intrusive_ptr&lt; <a class="el" href="class_grid_mate_1_1_driver_address.html">DriverAddress</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultCode *&#160;</td>
          <td class="paramname"><em>resultCode</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Receives a datagram and stores the source address. maxDataSize must be &gt;= than <a class="el" href="class_grid_mate_1_1_driver.html#a895218e87b2ac7f34be60e429c4e39a5" title="Return maximum data size we can send/receive at once in bytes, supported by the platform.">GetMaxSendSize()</a>. Returns the num of of received bytes. </p><dl class="section note"><dt>Note</dt><dd>If a datagram from a new connection is received, NewConnectionCB will be called. If it rejects the connection the returned from pointer will be NULL while the actual data will be returned. </dd></dl>

<p>Implemented in <a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a6da1e62d7d3a0ba06fa952cd90ec6235">GridMate::SocketDriverCommon</a>.</p>

</div>
</div>
<a id="a58ee4389496dfe5c16d83d1bcd23e982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ee4389496dfe5c16d83d1bcd23e982">&#9670;&nbsp;</a></span>StopWaitForData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GridMate::Driver::StopWaitForData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When you enter wait for data mode, for many reasons you might want to stop wait for data. If you implement this function you need to make sure it's a thread safe function. </p>

<p>Implemented in <a class="el" href="class_grid_mate_1_1_socket_driver_common.html#a78c7c6833f61f8075ebe5d4aae52a523">GridMate::SocketDriverCommon</a>.</p>

</div>
</div>
<a id="a1409b151a8b03054434fa8d923c75f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1409b151a8b03054434fa8d923c75f07">&#9670;&nbsp;</a></span>WaitForData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GridMate::Driver::WaitForData </td>
          <td>(</td>
          <td class="paramtype">AZStd::chrono::microseconds&#160;</td>
          <td class="paramname"><em>timeOut</em> = <code>AZStd::chrono::microseconds(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait for data to be to the ready for receive. Time out is the maximum time to wait before this function returns. If left to default value it will be in blocking mode (wait until data is ready to be received). </p><dl class="section return"><dt>Returns</dt><dd>true if there is data to be received (always true if timeOut == 0), otherwise false. </dd></dl>

<p>Implemented in <a class="el" href="class_grid_mate_1_1_socket_driver_common.html#ad40aab6eace5ad56fe0f163de005e6d3">GridMate::SocketDriverCommon</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Code/Framework/GridMate/GridMate/Carrier/Driver.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 5 2022 15:18:28 for Open 3D Engine GridMate API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
